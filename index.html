<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<title>ЕДА</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{ --bg:#f0f8ff; --panel:#ffffffcc; --accent:#ff6b6b; --text:#222; }
  html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;color:var(--text);overflow:hidden;}
  body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#e6f3ff 0%, var(--bg) 100%);padding:8px;box-sizing:border-box;}
  #gameWrap{width:1000px;max-width:100%;background:var(--panel);box-shadow:0 8px 30px rgba(0,0,0,0.12);border-radius:12px;overflow:hidden;height:100%;max-height:900px;display:flex;flex-direction:column;}
  header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #00000008;background:linear-gradient(90deg,#fff,#fbfdff);flex-shrink:0;} 
  header h1{font-size:18px;margin:0;flex:1;}
  header .controls{display:flex;gap:8px;align-items:center;}
  button{background:var(--accent);border:none;color:white;padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer;font-size:14px;min-height:36px;}
  button.secondary{background:#7aa7ff;}
  #gameContainer{position:relative;flex:1;overflow:hidden;min-height:0;}
  canvas{display:block;background:#e8f7ff;width:100%;height:100%;touch-action:none;}
  .hud{padding:10px 16px;display:flex;gap:12px;align-items:center;flex-wrap:wrap;flex-shrink:0;}
  .chip{background:#ffffffaa;padding:6px 10px;border-radius:999px;border:1px solid #00000006;font-weight:600;display:inline-flex;gap:8px;align-items:center;font-size:14px;}
  .muted{color:#666;font-weight:500;font-size:13px;margin-left:auto;}
  #overlay{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(255,255,255,0.98);padding:20px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.2);max-width:90%;width:620px;display:none;z-index:20;max-height:90%;overflow-y:auto;}
  .leaderboard{max-height:220px;overflow:auto;padding:8px;background:#f8fbff;border-radius:8px;border:1px solid #00000005;}
  footer{padding:8px 16px;border-top:1px solid #00000006;background:#fbfdff;font-size:13px;color:#555;flex-shrink:0;}
  .touch-controls{position:absolute;bottom:20px;left:0;right:0;display:flex;justify-content:space-between;padding:0 20px;pointer-events:none;z-index:10;display:none;}
  .touch-zone{width:120px;height:120px;background:rgba(255,255,255,0.3);border-radius:50%;pointer-events:auto;border:2px solid rgba(255,255,255,0.5);}
  @media (max-width:768px){ 
    header{flex-direction:column;gap:12px;align-items:stretch;}
    header h1{text-align:center;font-size:16px;}
    header .controls{justify-content:center;}
    .hud{justify-content:center;}
    .muted{display:none;}
    .touch-controls{display:flex;}
    button{padding:10px 16px;font-size:16px;}
  }
  @media (max-width:480px){
    header h1{font-size:14px;}
    .chip{font-size:12px;}
    .touch-zone{width:100px;height:100px;}
  }
</style>
</head>
<body>
<div id="gameWrap">
  <header>
    <h1>Лёля — класс: поедай, чтобы было вкусненько</h1>
    <div class="controls">
      <button id="startBtn">Старт</button>
      <button id="pauseBtn" class="secondary">Пауза</button>
      <button id="helpBtn" class="secondary">Правила</button>
    </div>
  </header>

  <div id="gameContainer">
    <canvas id="game"></canvas>
    
    <div class="touch-controls">
      <div class="touch-zone" id="touchLeft"></div>
      <div class="touch-zone" id="touchRight"></div>
    </div>

    <div id="overlay">
      <h2 id="ovTitle">Правила</h2>
      <p id="ovText">Управляй Валерией (мышь). Съедай нахуй первоклассников</p>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px">
        <button id="ovClose">Закрыть</button>
      </div>
    </div>
  </div>

  <div class="hud">
    <div class="chip">Счёт: <span id="score">0</span></div>
    <div class="chip">Время: <span id="time">60</span>s</div>
    <div class="chip">Режим: <span id="level">Лёгкий</span></div>
    <div class="muted">Управление:мышь (зажать)</div>
  </div>

  <footer>
    Съешь как можно больше вкусных сочных и маленьких первоклассников
  </footer>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const DPR = window.devicePixelRatio || 1;
function resize(){
  const container = document.getElementById('gameContainer');
  const rect = container.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.height * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
function fitCanvasSize(){
  const container = document.getElementById('gameContainer');
  const width = container.clientWidth;
  const height = container.clientHeight;
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';
  resize();
}
window.addEventListener('resize', ()=>{ fitCanvasSize(); });
fitCanvasSize();

let running = false, paused = false;
let score = 0; let timeLeft = 60; let spawnTimer = 0; let last = performance.now();
let difficulty = 1;
let targets = [], particles = [];

let obstacles = [];
function setupObstacles(){
  obstacles = [];
  const W = canvas.width/DPR, H = canvas.height/DPR;
  
  const deskW = Math.min(220, W*0.22);
  const deskH = 48;
  const margin = 40;
  const cols = Math.floor((W - margin*2) / (deskW + 20));
  const rows = 3;
  const startX = (W - (cols*deskW + (cols-1)*20))/2;
  const startY = 120;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const x = startX + c*(deskW+20);
      const y = startY + r*(deskH+40);
      obstacles.push({x,y,w:deskW,h:deskH, label:'desk'});
      
      obstacles.push({x: x + deskW*0.6, y: y + deskH + 6, w: deskW*0.2, h: 18, label:'chair'});
    }
  }
  
  obstacles.push({x: margin, y: H - 120, w: W - margin*2, h: 40, label:'podium'});
}
setupObstacles();

let player = {
  x: 200, y: 200, r: 28, vx:0, vy:0, speed: 220,
  skin:'#f2d1c9', hair:'#3b2b20', clothes:'#0d1b2a', hoodie:'#111', pants:'#cfd8e3'
};

const keys = {};
let usingMouse = false; let mousePos = {x:0,y:0,down:false};
let touchLeftActive = false, touchRightActive = false, touchJoystick = {x:0, y:0};

window.addEventListener('keydown',e=>{ keys[e.key.toLowerCase()] = true; if(e.key===' ') e.preventDefault(); });
window.addEventListener('keyup',e=>{ keys[e.key.toLowerCase()] = false; });

canvas.addEventListener('mousemove',e=>{ 
  if(!usingMouse) return;
  const r = canvas.getBoundingClientRect(); 
  mousePos.x=(e.clientX-r.left); 
  mousePos.y=(e.clientY-r.top); 
});
canvas.addEventListener('mousedown',e=>{ 
  usingMouse=true; 
  const r = canvas.getBoundingClientRect(); 
  mousePos.x=(e.clientX-r.left); 
  mousePos.y=(e.clientY-r.top); 
  mousePos.down=true; 
});
window.addEventListener('mouseup',e=>{ mousePos.down=false; });

function handleTouchStart(e){
  usingMouse = true;
  const touches = e.touches;
  for(let i = 0; i < touches.length; i++){
    const t = touches[i];
    const r = canvas.getBoundingClientRect();
    const x = t.clientX - r.left;
    const y = t.clientY - r.top;
    
    if(x < canvas.width/DPR/2){
      touchLeftActive = true;
      touchJoystick.x = x;
      touchJoystick.y = y;
    } else {
      touchRightActive = true;
      mousePos.x = x;
      mousePos.y = y;
      mousePos.down = true;
    }
  }
  e.preventDefault();
}

function handleTouchMove(e){
  const touches = e.touches;
  for(let i = 0; i < touches.length; i++){
    const t = touches[i];
    const r = canvas.getBoundingClientRect();
    const x = t.clientX - r.left;
    const y = t.clientY - r.top;
    
    if(touchLeftActive){
      touchJoystick.x = x;
      touchJoystick.y = y;
    }
    if(touchRightActive){
      mousePos.x = x;
      mousePos.y = y;
    }
  }
  e.preventDefault();
}

function handleTouchEnd(e){
  const touches = e.touches;
  if(touches.length === 0){
    touchLeftActive = false;
    touchRightActive = false;
    mousePos.down = false;
  } else {
    for(let i = 0; i < touches.length; i++){
      const t = touches[i];
      const r = canvas.getBoundingClientRect();
      const x = t.clientX - r.left;
      
      if(x < canvas.width/DPR/2){
        touchLeftActive = true;
      } else {
        touchRightActive = true;
      }
    }
  }
  e.preventDefault();
}

canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
canvas.addEventListener('touchend', handleTouchEnd, {passive: false});
canvas.addEventListener('touchcancel', handleTouchEnd, {passive: false});

const maxTargets = 60;
function spawnTarget(){
  if(targets.length >= maxTargets) return;
  const W = canvas.width/DPR, H = canvas.height/DPR;
 
  let x,y,tries=0;
  do{
    x = Math.random()*(W-60)+30;
    y = Math.random()*(H-140)+80;
    tries++;
    if(tries>80) break;
  }while(pointInsideAnyObstacle(x,y));
  const t = { x,y, r: 10 + Math.random()*6, speed: 28 + Math.random()*40, vx:0, vy:0, color:'#3a6eff', state:'wandering', hideTimer:0 };
  
  const ang=Math.random()*Math.PI*2; t.vx=Math.cos(ang)*t.speed; t.vy=Math.sin(ang)*t.speed;
  targets.push(t);
}

function pointInsideAnyObstacle(x,y){
  for(const o of obstacles){ if(x>o.x && x<o.x+o.w && y>o.y && y<o.y+o.h) return true; } return false;
}

function spawnParticles(x,y,color,count=18){ for(let i=0;i<count;i++){ const a=Math.random()*Math.PI*2; const s=60+Math.random()*160; particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:0.5+Math.random()*0.6,age:0,size:2+Math.random()*4,color}); } }

function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

function circleRectCollision(cx,cy,r,rect){
  const closestX = clamp(cx, rect.x, rect.x + rect.w);
  const closestY = clamp(cy, rect.y, rect.y + rect.h);
  const dx = cx - closestX;
  const dy = cy - closestY;
  return {collide: (dx*dx + dy*dy) < r*r, overlapX: dx, overlapY: dy};
}

function lineIntersectsRect(x1,y1,x2,y2,rect){
  function segIntersects(x1,y1,x2,y2,x3,y3,x4,y4){
    const det = (x2-x1)*(y4-y3) - (y2-y1)*(x4-x3);
    if(Math.abs(det) < 1e-6) return false;
    const t = ((x3-x1)*(y4-y3) - (y3-y1)*(x4-x3)) / det;
    const u = ((x3-x1)*(y2-y1) - (y3-y1)*(x2-x1)) / det;
    return t>=0 && t<=1 && u>=0 && u<=1;
  }
  const rx=rect.x, ry=rect.y, rw=rect.w, rh=rect.h;
  
  if(segIntersects(x1,y1,x2,y2, rx,ry, rx+rw,ry)) return true;
  if(segIntersects(x1,y1,x2,y2, rx+rw,ry, rx+rw,ry+rh)) return true;
  if(segIntersects(x1,y1,x2,y2, rx+rw,ry+rh, rx,ry+rh)) return true;
  if(segIntersects(x1,y1,x2,y2, rx,ry+rh, rx,ry)) return true;
  
  if(x1>rx && x1<rx+rw && y1>ry && y1<ry+rh) return true;
  if(x2>rx && x2<rx+rw && y2>ry && y2<ry+rh) return true;
  return false;
}

function update(dt){
  if(!running || paused) return;
  spawnTimer -= dt;
  if(spawnTimer <= 0){ spawnTarget(); spawnTimer = Math.max(0.25, 0.9 - difficulty*0.06 + Math.random()*0.4); }

  if(usingMouse && (mousePos.down || touchRightActive)){
    const target = {x: mousePos.x, y: mousePos.y};
    const dx = target.x - player.x, dy = target.y - player.y; const distTo = Math.hypot(dx,dy);
    if(distTo > 4){ player.vx = dx/distTo * player.speed; player.vy = dy/distTo * player.speed; } else { player.vx = player.vy = 0; }
  } else if(touchLeftActive){
    const dx = touchJoystick.x - player.x;
    const dy = touchJoystick.y - player.y;
    const distTo = Math.hypot(dx, dy);
    if(distTo > 10){
      player.vx = dx/distTo * player.speed;
      player.vy = dy/distTo * player.speed;
    }
  } else {
    let ax=0, ay=0;
    if(keys['arrowleft']||keys['a']) ax -= 1; if(keys['arrowright']||keys['d']) ax += 1;
    if(keys['arrowup']||keys['w']) ay -= 1; if(keys['arrowdown']||keys['s']) ay += 1;
    if(ax!==0 || ay!==0){ const mag = Math.hypot(ax,ay); player.vx = (ax/mag)*player.speed; player.vy = (ay/mag)*player.speed; }
    else { player.vx *= 0.82; player.vy *= 0.82; }
  }
  player.x += player.vx * dt; player.y += player.vy * dt;

  const W = canvas.width/DPR, H = canvas.height/DPR;
  player.x = clamp(player.x, player.r, W-player.r); player.y = clamp(player.y, player.r, H-player.r - 6);

  for(const o of obstacles){
    const res = circleRectCollision(player.x, player.y, player.r, o);
    if(res.collide){
      const overlap = Math.hypot(res.overlapX, res.overlapY);
      if(overlap > 0){
        const nx = res.overlapX / overlap; const ny = res.overlapY / overlap;
        player.x += nx * (player.r - overlap + 0.5);
        player.y += ny * (player.r - overlap + 0.5);
        player.vx *= 0.4; player.vy *= 0.4;
      }
    }
  }

  for(let i=targets.length-1;i>=0;i--){
    const t = targets[i];
    const dx = player.x - t.x, dy = player.y - t.y; const d = Math.hypot(dx,dy);
    let blocked = false;
    for(const o of obstacles){ if(lineIntersectsRect(player.x, player.y, t.x, t.y, o)){ blocked = true; break; } }

    if(d < 120 && !blocked){
      const nx = (t.x - player.x)/d; const ny = (t.y - player.y)/d;
      t.vx += nx * 140 * dt; t.vy += ny * 140 * dt;
      t.hideTimer = 0.6;
    } else {
      t.wiggle = (t.wiggle || 0) + dt*2;
      t.vx += Math.cos(t.wiggle)*10*dt; t.vy += Math.sin(t.wiggle)*8*dt;
      if(Math.random() < 0.01) { const ang = Math.random()*Math.PI*2; t.vx += Math.cos(ang)*40; t.vy += Math.sin(ang)*40; }
    }

    const sp = Math.hypot(t.vx, t.vy);
    if(sp > t.speed) { t.vx = (t.vx/sp)*t.speed; t.vy = (t.vy/sp)*t.speed; }
    t.x += t.vx * dt; t.y += t.vy * dt;

    if(pointInsideAnyObstacle(t.x, t.y)){
      t.x -= t.vx * dt * 1.6; t.y -= t.vy * dt * 1.6;
      t.vx *= -0.6; t.vy *= -0.6;
    }

    const distToPlayer = Math.hypot(player.x - t.x, player.y - t.y);
    let losBlocked = false;
    for(const o of obstacles){ if(lineIntersectsRect(player.x, player.y, t.x, t.y, o)){ losBlocked = true; break; } }
    if(distToPlayer < player.r + t.r*0.8 && !losBlocked){
      score += Math.ceil(1 + difficulty*0.8);
      document.getElementById('score').textContent = score;
      spawnParticles(t.x, t.y, '#ff3b3b');
      targets.splice(i,1);
      continue;
    }
  }

  for(let i=particles.length-1;i>=0;i--){ const p = particles[i]; p.age += dt; if(p.age >= p.life){ particles.splice(i,1); continue; } p.x += p.vx*dt; p.y += p.vy*dt; p.vx *= 0.98; p.vy *= 0.98; }

  timeLeft -= dt; document.getElementById('time').textContent = Math.max(0, Math.floor(timeLeft)); if(timeLeft <= 0) endGame();

  difficulty = 1 + (60 - Math.max(0, timeLeft))/20;
  const lvlEl = document.getElementById('level'); if(difficulty < 1.6) lvlEl.textContent = 'Лёгкий'; else if(difficulty < 2.6) lvlEl.textContent = 'Средний'; else lvlEl.textContent = 'Хард';
}

function drawObstacles(){
  for(const o of obstacles){
    if(o.label === 'desk'){
      ctx.fillStyle = '#d3b58b'; ctx.fillRect(o.x, o.y, o.w, o.h);
      ctx.fillStyle = '#8b6a45'; ctx.fillRect(o.x+6, o.y+o.h-4, 8, o.h+8);
      ctx.fillRect(o.x+o.w-14, o.y+o.h-4, 8, o.h+8);
      ctx.fillStyle = 'rgba(0,0,0,0.06)'; ctx.fillRect(o.x, o.y+o.h-3, o.w, 3);
    } else if(o.label === 'chair'){
      ctx.fillStyle = '#a27a56'; ctx.fillRect(o.x, o.y, o.w, o.h);
    } else if(o.label === 'podium'){
      ctx.fillStyle = '#cbb291'; ctx.fillRect(o.x, o.y, o.w, o.h);
      ctx.fillStyle = '#00000008'; ctx.fillRect(o.x, o.y+o.h-6, o.w, 6);
    }
  }
}

function drawPlayer(p){
  ctx.save();
  ctx.beginPath(); ctx.ellipse(p.x, p.y + p.r + 8, p.r*1.6, p.r*0.6, 0, 0, Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.fill();
  ctx.beginPath(); ctx.ellipse(p.x, p.y + p.r*0.45, p.r*0.95, p.r*0.9, 0, 0, Math.PI*2); ctx.fillStyle = p.clothes; ctx.fill();
  ctx.beginPath(); ctx.arc(p.x, p.y - p.r*0.15, p.r*0.75, 0, Math.PI*2); ctx.fillStyle = p.skin; ctx.fill();
  ctx.beginPath(); ctx.moveTo(p.x - p.r*0.7, p.y - p.r*0.5);
  ctx.quadraticCurveTo(p.x, p.y - p.r*1.05, p.x + p.r*0.6, p.y - p.r*0.45);
  ctx.lineTo(p.x + p.r*0.6, p.y - p.r*0.15);
  ctx.quadraticCurveTo(p.x, p.y - p.r*0.6, p.x - p.r*0.65, p.y - p.r*0.15);
  ctx.closePath(); ctx.fillStyle = p.hair; ctx.fill();
  ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(p.x - p.r*0.22, p.y - p.r*0.2, p.r*0.14, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(p.x + p.r*0.18, p.y - p.r*0.18, p.r*0.12, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(p.x - p.r*0.22, p.y - p.r*0.2, p.r*0.06, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(p.x + p.r*0.18, p.y - p.r*0.18, p.r*0.05, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(p.x, p.y - p.r*0.02, p.r*0.28, 0, Math.PI); ctx.lineWidth = 2; ctx.strokeStyle = '#000'; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(p.x - p.r*0.8, p.y + p.r*0.1); ctx.quadraticCurveTo(p.x - p.r*0.3, p.y + p.r*0.2, p.x - p.r*0.05, p.y + p.r*0.1); ctx.lineWidth = 8; ctx.strokeStyle = p.clothes; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(p.x + p.r*0.8, p.y + p.r*0.1); ctx.quadraticCurveTo(p.x + p.r*0.3, p.y + p.r*0.2, p.x + p.r*0.05, p.y + p.r*0.1); ctx.lineWidth = 8; ctx.strokeStyle = p.clothes; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(p.x - p.r*0.35, p.y + p.r*0.9); ctx.lineTo(p.x - p.r*0.15, p.y + p.r*1.4); ctx.lineWidth = 12; ctx.strokeStyle = p.pants; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(p.x + p.r*0.35, p.y + p.r*0.9); ctx.lineTo(p.x + p.r*0.15, p.y + p.r*1.4); ctx.lineWidth = 12; ctx.strokeStyle = p.pants; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(p.x + p.r*0.45, p.y - p.r*0.05); ctx.quadraticCurveTo(p.x + p.r*0.15, p.y + p.r*0.2, p.x - p.r*0.2, p.y + p.r*0.35); ctx.lineWidth = 6; ctx.strokeStyle = '#fff'; ctx.stroke();
  ctx.restore();
}

function drawTarget(t){
  ctx.save();
  ctx.beginPath(); ctx.ellipse(t.x, t.y + t.r + 3, t.r*1.1, t.r*0.5, 0, 0, Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.08)'; ctx.fill();
  ctx.beginPath(); ctx.arc(t.x, t.y - t.r*0.25, t.r*0.6, 0, Math.PI*2); ctx.fillStyle = '#ffd9c7'; ctx.fill();
  ctx.beginPath(); ctx.ellipse(t.x, t.y + t.r*0.35, t.r*0.9, t.r*0.6, 0, 0, Math.PI*2); ctx.fillStyle = t.color; ctx.fill();
  ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(t.x - t.r*0.18, t.y - t.r*0.3, t.r*0.12, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(t.x + t.r*0.07, t.y - t.r*0.28, t.r*0.1, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(t.x - t.r*0.18, t.y - t.r*0.3, t.r*0.04, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(t.x + t.r*0.07, t.y - t.r*0.28, t.r*0.035, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawParticles(){ for(const p of particles){ ctx.globalAlpha = Math.max(0, 1 - p.age/p.life); ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fillStyle = p.color; ctx.fill(); ctx.globalAlpha = 1; } }

function drawBackground(){
  const W = canvas.width/DPR, H = canvas.height/DPR;
  ctx.fillStyle = '#f7fbff'; ctx.fillRect(0,0,W,H);
  ctx.fillStyle = '#cfe9ff'; ctx.fillRect(12,12, W*0.18, 80);
  ctx.fillStyle = '#1b2b34'; ctx.fillRect(W*0.06, 20, W*0.88, 48);
  ctx.fillStyle = '#93c2ff'; ctx.font = '18px Inter, Arial'; ctx.fillText('Аудитория 270722 — практика', W*0.07, 52);
}

function draw(){
  const W = canvas.width/DPR, H = canvas.height/DPR;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBackground();
  drawObstacles();
  for(const t of targets) drawTarget(t);
  drawPlayer(player);
  drawParticles();
}

function tick(now){ const dt = Math.min(0.05, (now - last)/1000); last = now; update(dt); draw(); requestAnimationFrame(tick); }

function startGame(){ running=true; paused=false; score=0; timeLeft=60; targets=[]; particles=[]; spawnTimer=0.2; difficulty=1;
  const W = canvas.width/DPR, H = canvas.height/DPR; player.x = W/2; player.y = H/2; player.vx=0; player.vy=0; document.getElementById('score').textContent = score; document.getElementById('time').textContent = timeLeft; document.getElementById('startBtn').textContent='Рестарт'; document.getElementById('pauseBtn').textContent='Пауза'; last = performance.now(); setupObstacles(); requestAnimationFrame(tick);
}
function endGame(){ running=false; paused=false; showOverlayScore(); }
function togglePause(){ if(!running) return; paused=!paused; document.getElementById('pauseBtn').textContent = paused ? 'Продолжить' : 'Пауза'; }

const overlay = document.getElementById('overlay'); const ovTitle = document.getElementById('ovTitle'); const ovText = document.getElementById('ovText');
function showOverlay(text,title='Информация'){ ovTitle.textContent = title; ovText.innerHTML = text; overlay.style.display = 'block'; }
document.getElementById('helpBtn').addEventListener('click', ()=>{ showOverlay('Управляй: стрелки или зажми и веди пальцем/мышью. Ешь вкуснятину','Правила'); });
document.getElementById('ovClose').addEventListener('click', ()=> overlay.style.display='none');

function showOverlayScore(){ const name = prompt('Итог: вы съели ' + score + ' очков! введите имя этого чемпиона-поедателя для рекордов (оставьте пустым — будет "Игрок")') || 'Игрок'; const board = getBoard(); board.push({name,score, date: new Date().toISOString()}); board.sort((a,b)=>b.score-a.score); while(board.length>10) board.pop(); saveBoard(board);
  let html = '<p>Ваш счёт: <b>' + score + '</b></p>' + '<div class="leaderboard"><ol style="padding-left:18px;margin:0">'; for(const row of board){ const d=new Date(row.date); html += `<li style="margin:6px 0"><b>${escapeHtml(row.name)}</b> — ${row.score} <span style="color:#777;font-size:12px">(${d.toLocaleString()})</span></li>`; } html += '</ol></div>';
  html += '<div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px"><button id="replayBtn">Играть снова</button><button id="closeBtn">Закрыть</button></div>';
  overlay.innerHTML = `<h2>Результат</h2>${html}`; overlay.style.display='block'; document.getElementById('replayBtn').addEventListener('click', ()=>{ overlay.style.display='none'; startGame(); }); document.getElementById('closeBtn').addEventListener('click', ()=>{ overlay.style.display='none'; }); }
function getBoard(){ try{ return JSON.parse(localStorage.getItem('valeria_board')||'[]'); }catch(e){ return []; } }
function saveBoard(b){ localStorage.setItem('valeria_board', JSON.stringify(b)); }
function escapeHtml(s){ return String(s).replace(/[&<>\"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[c]); }

document.getElementById('startBtn').addEventListener('click', ()=> startGame());
document.getElementById('pauseBtn').addEventListener('click', ()=> togglePause());

setInterval(()=>{ if(running && !paused && Math.random()<0.45) spawnTarget(); }, 1000);
canvas.addEventListener('contextmenu',e=>e.preventDefault());

player.x = (canvas.width/DPR)/2; player.y = (canvas.height/DPR)/2; 
showOverlay('Управляй (стрелки или мышь). Аудитория. Время: 60 с.','Добро пожаловать на поляну');
</script>
</body>
</html>
